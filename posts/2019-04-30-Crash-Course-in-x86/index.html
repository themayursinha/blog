<!DOCTYPE html>
<html lang="en">
  <!-- Beautiful Jekyll | MIT license | Copyright Dean Attali 2016 -->
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
  <script src="/js/theme-init.js"></script>

  <title>Crash Course in x86 - Part I</title>

  <meta name="author" content="Mayur Sinha" />

  

  <link rel="alternate" type="application/rss+xml" title="Mayur Sinha - Mayur" href="/feed.xml" />

  

  

  
<!-- Google Analytics -->
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-136557652-1', 'auto');
    ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



  
    
      
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet" integrity="sha384-blOohCVdhjmtROpu8+CfTnUWham9nkX7P7OZQMst+RUnhtoY/9qemFAkIKOYxDI3" crossorigin="anonymous">


    
      
  <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-social/5.1.1/bootstrap-social.min.css" rel="stylesheet" integrity="sha384-N7gull5mxE2uLDqZ+kcZolhmuopwLtTcThUsVnUS2LVMQljojN9cfJ9A6fUA63zB" crossorigin="anonymous">


    
  

  
    
      <link rel="stylesheet" href="/css/bootstrap.min.css" />
    
      <link rel="stylesheet" href="/css/main.css" />
    
      <link rel="stylesheet" href="/css/nav-enhancements.css" />
    
  

  
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
    
  

  

  

  

  <!-- Facebook OpenGraph tags -->
  

  
  <meta property="og:title" content="Crash Course in x86 - Part I" />
  

  
  <meta property="og:description" content="Knowledge of x86 is important in security fields like malware analysis, vulnerability research and exploit development. The only prerequisite is to know the basics of C or C based languages like Java. Bits, bytes, words, double words The data “types” in 32 bits assembly are bits, bytes, words, and dwords....">
  

  <meta property="og:type" content="website" />

  
  <meta property="og:url" content="https://themayursinha.com/posts/2019-04-30-Crash-Course-in-x86/" />
  <link rel="canonical" href="https://themayursinha.com/posts/2019-04-30-Crash-Course-in-x86/" />
  

  
  <meta property="og:image" content="https://themayursinha.com/img/hacker.jpg" />
  

  <!-- Twitter summary cards -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <meta name="twitter:creator" content="@" />

  
  <meta name="twitter:title" content="Crash Course in x86 - Part I" />
  

  
  <meta name="twitter:description" content="Knowledge of x86 is important in security fields like malware analysis, vulnerability research and exploit development. The only prerequisite is to know the basics of C or C based languages like Java. Bits, bytes, words, double words The data “types” in 32 bits assembly are bits, bytes, words, and dwords....">
  

  
  <meta name="twitter:image" content="https://themayursinha.com/img/hacker.jpg" />
  

  

  

  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script>

  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Roboto+Slab:wght@400;700&display=swap" rel="stylesheet">
</head>


  <body>

    

  
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
        <a class="navbar-brand" href="https://themayursinha.com">Mayur Sinha</a>
      
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
        
          
            
              <li>






<a href="https://themayursinha.com">Home</a>
</li>
            
          
            
          
            
          
        
          
            
          
            
              <li>






<a href="/projects">Projects</a>
</li>
            
          
            
          
        
          
            
          
            
          
            
              <li>






<a href="/posts">Posts</a>
</li>
            
          
        
          
            
          
            
          
            
          
        
        <li class="navbar-search">
          <button id="search-toggle" class="navbar-icon-button" type="button" aria-label="Open search">
            <i class="fa fa-search" aria-hidden="true"></i>
          </button>
        </li>
        <li class="navbar-theme-toggle">
          <a href="#" id="theme-toggle" class="navbar-icon-link" title="Toggle dark/light mode" aria-label="Toggle dark or light mode">
            <i id="theme-toggle-icon" class="fa fa-moon" aria-hidden="true"></i>
          </a>
        </li>
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a href="https://themayursinha.com">
            <img class="avatar-img" src="/img/hacker.jpg" />
          </a>
        </div>
      </div>
    
  </div>
</nav>

<div id="search-modal" class="search-modal" aria-hidden="true">
  <div class="search-modal-card" role="dialog" aria-modal="true" aria-label="Search posts">
    <button id="search-modal-close" class="search-modal-close" type="button" aria-label="Close search">&times;</button>
    <div class="search-modal-header">
      <i class="fa fa-search search-modal-icon" aria-hidden="true"></i>
      <input type="text" id="search-modal-input" class="search-modal-input" placeholder="Search posts..." autocomplete="off" />
      <span class="search-modal-hint" aria-hidden="true">ESC</span>
    </div>
    <div id="search-modal-results" class="search-modal-results"></div>
  </div>
</div>


    <!-- TODO this file has become a mess, refactor it -->





<header class="header-section ">

<div class="intro-header no-img">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <h1>Crash Course in x86 - Part I</h1>
		  
		  
		  
		  <span class="post-meta">Posted on April 30, 2019</span>
		  
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class="container">
  <div class="row">
    <!-- Main content column -->
    <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1">
      

      <article role="main" class="blog-post">
        <p>Knowledge of x86 is important in security fields like malware analysis, vulnerability research and exploit development. The only prerequisite is to know the basics of C or C based languages like Java.</p>

<h4 id="bits-bytes-words-double-words">Bits, bytes, words, double words</h4>
<p>The data “types” in 32 bits assembly are bits, bytes, words, and dwords.
The smallest of them is the bit, which can be either 0 or 1.
A byte is eight bits put together and can be between 0 and 255
A word is two bytes put together, or sixteen bits, and can have a maximum value of 65535.
A dword is two words (d in dword stands for double), four bytes or 32 bits. The maximum value is 4294967295.</p>

<h4 id="registers">Registers</h4>
<p>A register is a small storage space available as part of the CPU. This also implies that registers are typically addressed by other mechanisms than main memory and are much faster to access. Registers are used to store values for future usage by the CPU and they can be divided into the following classes.</p>

<h4 id="general-purpose-registers">General purpose registers</h4>
<p>Used by the CPU during execution. There are eight of them and the original idea of Intel engineers was that most of these registers should be used for certain tasks (their names hint the type of task intended). But during the years and the development of Intel architecture each and every one of these can be used as general purpose register. That is however not recommended. EBP and ESP should be avoided as much as possible, as using them without saving and restoring their original values means the functions stack frame will be messed up and the program will crash.</p>

<p>EAX) Extended Accumulator Register
EBX) Extended Base Register
ECD) Extended Counter Register
EDX) Extended Data Register
ESI) Extended Source Index
EDI) Extended Destination Index
EBP) Extended Base Pointer
ESP) Extended Stack Pointer</p>

<p>All the general purpose registers are 32-bit size in Intel’s IA-32 architecture but depending on their origin and intended purpose, a subset of some of them can be referenced in assembly. Below is the complete list.</p>

<p><img src="https://themayursinha.com/img/reg.png" alt="reg" /></p>

<p>AX to SP are the 16 bit registers used to reference the 16 least significant bits in their equivalent 32 bit registers. The eight bit registers reference the higher and lower eight bits of the 16 bit registers.</p>

<h4 id="segment-registers">Segment registers</h4>
<p>Segment registers are used to make segmental distinctions in the binary. We will approach segments later but in short, the hexadecimal value 0x90 can either represent an instruction or a data value. The CPU knows which one thanks to segment registers.</p>

<h4 id="status-flag-registers">Status flag registers</h4>
<p>Flags are tiny bit values that are either set (1) or not set (0). Each flag represent a status. For example, if the “signed” flag is set, the value of FF will represent a -1 in decimal notation instead of 255. Flags are all stored in special flag register, were many one bit flags are stored at once. The flags are set whenever an operation resulted in certain state or output. The flags we are most interested in for now are:
Z – zero flag, set when the result of the last operation is zero
S – signed flag, set to determine if values should be intercepted as signed or unsigned
O – overflow flag, set when the result of the last operation switches the most significant bit from either F to 0 or 0 to F.
C – carry flag, set when the result of the last operation changes the most significant bit</p>

<h4 id="eip---extended-instruction-pointer">EIP - Extended Instruction Pointer</h4>
<p>The instruction pointer has the same function in a CPU as the needle had in those old gramophones your grandpa used to have. It points to the next instruction to be executed.</p>

<h4 id="segments--offsets">Segments &amp; offsets</h4>
<p>Every program consists of several different segments. Four segments that each program must have are .text, .data, .stack and .heap. The program code is put in .text and global data is stored in .data. The stack is where, among many things, local variable and function arguments, are stored and the heap is an extendable memory segment that programs can use whenever they need more memory space.</p>

<h4 id="the-stack">The stack</h4>
<p>The stack is the part of memory where a program stores local variables and function arguments (among many things) for later use. It is organized as a “Last In First Out” data structure. When something is added to the stack, it is added on top of it and when something is removed, it is removed from the top. Another very important feature about the stack is that it grows backwards, from the highest memory address to the lowest, more about that in a moment.
Two registers that are customized to work closely with the stack are the ESP and EBP. The ESP is the stack pointer and always points to the top of the stack. When something is added to the stack, the stack grows. This means the ESP needs to be corrected to point to the new “top” of the stack, which is done by decrementing ESP. Again, this is because the stack grows backwards, from highest address to lowest.</p>

<h4 id="stack-frames">Stack frames</h4>
<p>The EBP is the base pointer but what does base mean? Well, every process has at least one thread, and every thread has its own stack. And within the stack of every thread, each function has its own stack frame. The base is the beginning of a stack frame. The main function in every program has its stack, when it calls a function the called function creates its own stack frame which is marked out by the EBP that points to the beginning of the functions stack frame and the ESP that points to the top of the stack. More about this subject later.</p>

<h4 id="the-heap">The Heap</h4>
<p>The heap is memory space that can be allocated by a process when it needs more memory. Each process has one heap and it is shared among the different threads. All the threads share the same heap. The heap is a Linked-List data structure, which means each item only knows the position of the immediate items before and after it. When the process does not need the memory anymore, it is custom to “free” the allocated heap. This is done by de-referencing the no longer required portion and allowing other processes to use it.</p>

<h4 id="instructions">Instructions</h4>
<p>Intel instructions vary in size from one to fourteen bytes. The opcode (short for operation code) is mandatory for them all and can be combined with other optional or mandatory bytes to create advanced instructions. This is a vast topic and further reading is done at the links below for those who want. If not, the disassembler will do the job for you, but it can be good to know why opcode 83 sometimes is disassembled as an add and other times as an and instruction when you look in your disassembler. Below links will explain that indirectly.
http://www.swansontec.com/sintel.html
http://ref.x86asm.net/coder32.html
Most instructions have two operators (like add eax, ebx), but some have one (not eax) or even three (“imul eax, edx, 64”). Instructions that contain something with “dword ptr [eax]” reference the double word (4 byte) value at memory offset [XXX]. Note that the bytes are saved in reverse order in the memory as Intel uses Little Endian representation. That means the most significant bit of every byte is the most left bit.</p>

<h4 id="arithmetic-operations---add--sub-mul-imul-div-idiv">Arithmetic operations - ADD , SUB, MUL, IMUL, DIV, IDIV…</h4>
<p>ADD, syntax: add dest, src
Destination and source can be either a register like eax, a memory reference [esp] (anything surrounded by square brackets is an address reference). The source can also be an immediate number. Noteworthy is that both destination and source cannot be a memory reference at the same time. Both can however be registers.
add eax, ebx        ; both dest and src are registers
add [esp], eax      ; dest is a memory reference to the top of the stack, source is the eax register
add eax, [esp]      ; like the previous example but with the roles reversed
add eax, 4          ; source is an immediate value</p>

<p>The sub instruction works exactly as the add instruction.
SUB, syntax:  sub dest, src</p>

<p>The division and multiplication instructions are a little different, let’s go through division first.
DIV/IDIV, syntax: div divisor</p>

<p>The dividend is always eax and that is also were the result of the operation is stored. The rest value is stored in edx.<br />
mov eax, 65         ; move the dividend into eax
mov ecx, 4          ; move the divisor into ecx
div ecx             ; divide eax by ecx, this will result in eax containing 16 and edx containing the rest, which is 1</p>

<p>IDIV is the same as DIV but signed division.</p>

<p>MUL/IMUL, syntax:   mul value
                    mul dest, value, value
                    mul dest, value</p>

<p>mul/imul (unsigned/signed) multiply either eax with a value, or they multiply two values and put them into a destination register or they multiply a register with a value.</p>

<h4 id="bitwise-operations--and-or-xor-not">Bitwise operations – AND, OR, XOR, NOT</h4>
<p>AND, syntax:      add dest, src
OR, syntax:       or dest, src
XOR, syntax:      xor dest, src
NOT, syntax:      not eax</p>

<p>Bitwise operations are what their name suggests. Two pieces of data are being compared bit by bit and depending on the operation, the outcome is either a 0 or a 1. Consider below two values:</p>

<p>value 1:          10011011
value 2:          11001001
output:           ????????</p>

<p>If the operation is AND the output would be 10001001 since only the 1st, 5th and 8th bits in both value 1 and 2 are set. That is what AND means, it checks for equally positioned bits that are both set.
If the operation would be OR, it would check for any set bites and as long as a bit is set in either value 1 or value 2, it would set the equivalent bit in the output. Hence the result of an OR would be 11011011.
The XOR is like the OR but with one very important distinction. It will not set bits in the output were both bits are set, instead it will only set bits that are exclusively set in either value 1 but not 2, or the other way around. The above example would give the following output: 01010010.
The way XOR works brings an interesting feature, any value XOR:ed with itself will become 0. Many compilers are making use of this feature of the XOR operation by XOR:ing a register with itself instead of moving the value 0 into it, as the XOR operation will go faster.
The NOT operation is different to the other bitwise operations as it only takes one value and inverses every bit. For example the value 11011110 would become 00100001 when NOT’d.</p>

<h4 id="branching--jmp-je-jle-jnz-jz-jbe-jge">Branching – JMP, JE, JLE, JNZ, JZ, JBE, JGE…</h4>
<p>JMP/JE/JLE…etc syntax:    jmp address</p>

<p>In assembly, branching is made through the use of jumps and flags. A jump is just an instruction that under certain circumstances will point the instruction pointer (EIP) to another portion of the code (much like the “goto” keyword in C). Flags are, as mentioned previously, tiny one bit values that can be set (1) or not set (0). Most instructions set one or more flags. Let’s revisit some of the instructions we already looked at and see which flags they set
ADD can set all of the Z, S, O, C flags (and some more that are of no interest to us right now) according to the result. Same is true for the SUB instruction.
The AND instruction however always clears the O and C flags, but sets Z and S flags according to the result.
Depending on which flags are set, a jump will either happen or not. As you see, there are always only two options in assembly branches and if you think about it, this is also true in all the more complex type of branches that higher level languages offer. A switch statement in C for example will always perform or not perform a case, then move on to the next case and once again decide whether to perform or not perform that case.
Two notes! First of all, most of the time you will see an instruction called CMP (which stands for compare) being used before a jump. CMP is the ideal pre-branch instruction as it can set all the status flags and is really fast. The syntax for CMP is: cmp dest, src
This does not mean the other instructions cannot be used before a jump, for example XOR occurs frequently but the most common is the CMP instruction.
The other important note is about the jump instructions. There are a lot of jump instructions and nobody can memorize them all. Often there are several jumps that look very much alike. For example, JLE stands for “Jump Less or Equal”. In C this would be:
if (x &lt;= y) { do this }
At the same time, JBE stands for “Jump Below or Equal”. Which in C would be:
if(x&lt;=y) {dothis}
So why these different jumps that looks exactly the same in C, one wonders? The answer is “due to signed and unsigned comparisons”. JLE is used to check the flags after a comparison between signed variables and JBE for unsigned comparisons. This was just an example, unless you memorize them all, you always need to read in the Intel Developer’s Guide to see which flags a jump checks for.</p>

<h4 id="data-moving--mov-movs-movsb-movsw-movzx-movsx-lea">Data moving – MOV, MOVS, MOVSB, MOVSW, MOVZX, MOVSX, LEA…</h4>
<p>MOV, syntax:        mov dest, src
MOVSB, syntax:      movzx dest, src
MOVZX, syntax:      movzx dest, src</p>

<p>MOV moves data from source into destination. Both source and destination can be register, or one of them register and the other one a memory reference. Both cannot be a memory reference however.
The mov instructions come in many flavours, just like the jump instructions, and partly for the same reason. MOVS/MOVSB/MOVSW/MOVSD for example copy a byte, word or dword from source to destination.
The mov instructions that have an X in their name are used for variable extension. In C it would for example be like a typecast from char to integer, like this</p>

<p>char a = ‘h’;
int b;
b = (int)a;</p>

<p>The instructions work like this</p>

<p>MOVSX) DEST &lt;– Signextend[SRC]
MOVZX) DEST &lt;– Zeroextend[SRC]</p>

<p>Where signed means the extension bits will hold the value of one.
Another instruction that can be used for data moving is the LEA instruction. LEA stands for “Load Effective Address” and the syntax looks like this:</p>

<p>lea eax, dword ptr[ecx+edx] ; This will store ecx+edx in eax</p>

<h4 id="loops--loop-rep">Loops – LOOP, REP…</h4>
<p>Although one can create neat loops using jumps, Intel’s x86 assembly also provides instructions specifically tailored to create iterating sequences of code. Like many of the other instructions we looked at, they come with many flavours depending of the size and sign of the variables they work with. For simplicity reasons, I will only show the easiest cases, LOOP first:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov ecx, 5 ; remember ecx stands for extended counter register
_proc:
dec ecx ; decrements ecx
loop _proc ; loops back to _procs, second row
</code></pre></div></div>

<p>REP instructions work like LOOP instructions, but are specifically customized to handle
strings (this is where IA-32 assembly almost becomes a high level language)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov esi, str1
mov edi, str2
mov, ecx, 10h
rep cmps
</code></pre></div></div>

<p>What happens here is that the strings to be compared are loaded into ESI and EDI and then a comparison is performed for 16 bytes (hexadecimal value 0x10 = 16 in decimal notation). If at some point the source and destination are not equal, a flag will be set and the operation will be aborted.</p>

      </article>

      
        <div class="blog-tags">
          Tags:
          
          
            <a href="/tags#security">security</a>
          
          
        </div>
      

      <ul class="pager blog-pager">
        
        <li class="previous">
          <a href="/posts/2018-03-15-exploit-mitigation-techniques/" data-toggle="tooltip" data-placement="top" title="Memory exploit mitigation techniques">&larr; Previous Post</a>
        </li>
        
        
        <li class="next">
          <a href="/posts/2020-04-12-Problem-solving-and-the-art-of-the-convincing-argument/" data-toggle="tooltip" data-placement="top" title="Problem solving and the art of the convincing argument">Next Post &rarr;</a>
        </li>
        
      </ul>

      
        <!-- Comment section removed -->
      
    </div>
    
    <!-- Sidebar column -->
    <div class="col-lg-3 col-md-12">
      <!-- Table of Contents -->
<div id="toc" class="toc-sidebar">
  <div id="toc-content" class="toc-content">
    <!-- TOC will be populated by JavaScript -->
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const article = document.querySelector('.blog-post');
  const tocContent = document.getElementById('toc-content');
  
  if (!article || !tocContent) {
    console.log('TOC: Article or TOC content not found');
    return;
  }
  
  // Look for headings in the article
  const headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
  console.log('TOC: Found', headings.length, 'headings');
  
  if (headings.length === 0) {
    // If no headings found in .blog-post, try the entire page
    const allHeadings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    console.log('TOC: Found', allHeadings.length, 'headings on entire page');
    
    // Filter out the page title and other non-content headings
    const contentHeadings = Array.from(allHeadings).filter(heading => {
      // Skip the main page title and navigation headings
      const isPageTitle = heading.closest('.intro-header') !== null;
      const isNavHeading = heading.closest('nav') !== null;
      const isTocHeading = heading.closest('#toc') !== null;
      return !isPageTitle && !isNavHeading && !isTocHeading;
    });
    
    console.log('TOC: Found', contentHeadings.length, 'content headings');
    
    if (contentHeadings.length > 0) {
      createTOC(contentHeadings);
    } else {
      document.getElementById('toc').style.display = 'none';
    }
  } else {
    createTOC(headings);
  }
  
  function createTOC(headings) {
    const toc = document.createElement('ul');
    toc.className = 'toc-list';
    
    headings.forEach((heading, index) => {
      // Add ID to heading if it doesn't have one
      if (!heading.id) {
        heading.id = 'heading-' + index;
      }
      
      const li = document.createElement('li');
      const a = document.createElement('a');
      
      a.href = '#' + heading.id;
      a.textContent = heading.textContent.trim();
      a.className = 'toc-link';
      
      // Add indentation based on heading level
      const level = parseInt(heading.tagName.charAt(1));
      if (level === 3) {
        li.style.paddingLeft = '20px';
      } else if (level === 4) {
        li.style.paddingLeft = '40px';
      } else if (level === 5) {
        li.style.paddingLeft = '60px';
      } else if (level === 6) {
        li.style.paddingLeft = '80px';
      }
      
      li.appendChild(a);
      toc.appendChild(li);
    });
    
    if (toc.children.length > 0) {
      tocContent.appendChild(toc);
    } else {
      document.getElementById('toc').style.display = 'none';
    }
  }
  
  // Improved smooth scrolling for TOC links with perfect heading position
  tocContent.addEventListener('click', function(e) {
    if (e.target.classList.contains('toc-link')) {
      e.preventDefault();
      const targetId = e.target.getAttribute('href').substring(1);
      const targetElement = document.getElementById(targetId);
      if (targetElement) {
        targetElement.scrollIntoView({ behavior: 'instant', block: 'start' });
        history.replaceState(null, '', '#' + targetId);
        requestAnimationFrame(() => {
          const navbar = document.querySelector('.navbar-custom');
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          window.scrollBy({ top: -navbarHeight - 8, left: 0, behavior: 'smooth' });
        });
      }
    }
  });
});
</script> 
    </div>
  </div>
</div>


    <footer class="beautiful-jekyll-footer">
  <div style="text-align:center;">
    <ul class="list-inline text-center footer-links"><li><a href="mailto:themayursinha@gmail.com" title="Email me"><span class="fa-stack fa-lg" aria-hidden="true">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-solid fa-envelope fa-stack-1x fa-inverse"></i>
            </span>
            <span class="sr-only">Email me</span>
          </a>
        </li><li><a href="https://github.com/themayursinha" title="GitHub"><span class="fa-stack fa-lg" aria-hidden="true">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-brands fa-github fa-stack-1x fa-inverse"></i>
            </span>
            <span class="sr-only">GitHub</span>
          </a>
        </li><li><a href="https://x.com/themayursinha" title="Twitter"><span class="fa-stack fa-lg" aria-hidden="true">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-brands fa-x-twitter fa-stack-1x fa-inverse"></i>
            </span>
            <span class="sr-only">Twitter</span>
          </a>
        </li><li><a href="https://goodreads.com/themayursinha" title="Goodreads"><span class="fa-stack fa-lg" aria-hidden="true">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-brands fa-goodreads-g fa-stack-1x fa-inverse"></i>
            </span>
            <span class="sr-only">Goodreads</span>
          </a>
        </li><li><a href="https://linkedin.com/in/mayursinha" title="LinkedIn"><span class="fa-stack fa-lg" aria-hidden="true">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-brands fa-linkedin fa-stack-1x fa-inverse"></i>
            </span>
            <span class="sr-only">LinkedIn</span>
          </a>
        </li></ul>
    <p class="copyright text-muted">
      Mayur Sinha
      &nbsp;&bull;&nbsp;
      2026

      

      
    </p>
  </div>
</footer>

  
    






  
    <script src="/js/jquery-3.7.0.min.js"></script>
  
    <script src="/js/bootstrap.min.js"></script>
  
    <script src="/js/main.js"></script>
  
    <script src="/js/nav-enhancements.js"></script>
  


  
  </body>
</html>
