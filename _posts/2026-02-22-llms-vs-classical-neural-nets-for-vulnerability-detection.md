---
layout: post
title: Why Transformer LLMs are better at finding code vulnerabilities than classical neural networks
categories: [AI, security]
tags: [ai, security, llms]
description: A technical comparison of classical ANN pipelines and transformer LLMs for vulnerability detection.
share-img: /img/circuit.png
related_posts:
  - Reframing Application Security â€” A Developer Experience Perspective
  - Vibe Engineering
  - Designing a living ecosystem of AI agents
---

I have worked with both worlds.

Earlier in my career, including work at Trend Micro, I spent time experimenting with ANN pipelines for shellcode detection. Those systems were useful for bounded classification tasks on network payloads. They were not designed for deep reasoning across large codebases.

That difference is the core of this post.

The question is not "are LLMs neural networks". They are. The useful comparison is this:

- classical task-specific models, often MLP, CNN, RNN, or LSTM, trained on narrow labeled security datasets
- transformer foundation models that can reason across larger context with stronger semantic priors

## The detection problem is different now

Shellcode classification and source-level vulnerability analysis are not the same learning problem.

Shellcode classification can often be framed as:

- input: payload bytes or engineered byte features
- output: benign or malicious class

Code vulnerability analysis is usually closer to:

- input: many files plus framework behavior and data flow
- output: exploitability claim with path constraints

The second problem is harder because it requires reasoning over:

- long-range dependencies
- control flow and data flow
- security invariants like authorization scope, sanitization state, and trust boundaries

## What classical ANN pipelines do well

In constrained settings, classical models can perform very well.

A typical older pipeline looks like this:

1. Build fixed-size input vectors, often byte windows, n-grams, or tokenized snippets.
2. Train supervised classifier with cross-entropy on labeled corpora.
3. Optimize for precision or recall on known classes.

This works when the distribution is stable and the target class is local in the input representation.

That matches many shellcode scenarios:

- local opcode patterns
- known packing behavior
- repeated exploit families

In my own shellcode experiments, the model quality looked good when train and test distributions were close. Performance dropped when payload structure shifted, especially with obfuscation and polymorphic transforms.

## Why transformers changed the vulnerability workflow

### 1. Long-range dependency handling

For sequential models, information is compressed as hidden state evolves:

- `h_t = f(x_t, h_{t-1})`

In practice, useful signal from far earlier tokens gets diluted as sequence length grows. Attention-based models build direct pairwise interactions inside the context window:

- `Attention(Q, K, V) = softmax(QK^T / sqrt(d_k))V`

For vulnerability detection, this matters because source and sink can be far apart.

A second-order SQL injection pattern is a simple example:

```python
# file A
name = sanitize(request.POST["name"])
db.execute("INSERT INTO users(name) VALUES (?)", (name,))

# file B, later
for user in db.execute("SELECT name FROM users"):
    q = f"SELECT * FROM logs WHERE name = '{user.name}'"
    db.execute(q)
```

A local classifier may miss that the sink in file B still depends on attacker input. A transformer can keep both regions active in the same reasoning step.

### 2. Semantic reasoning over program intent

Many high-impact bugs are logic bugs, not token signatures.

Example:

```javascript
const actor = getUserFromToken(req.headers.authorization);
if (actor.role !== 'admin') return deny();
const target = getUserById(req.query.userId);
deleteUser(target.id);
```

No dangerous API name appears. The flaw is semantic:

- authorization is checked for `actor`
- action is executed on `target` from client-controlled input

Pattern-heavy models miss this more often because the bug is a violated security invariant, not a lexical smell.

### 3. Better behavior under data scarcity

Security labels are expensive and noisy.

- Ground truth is often incomplete.
- CVE labels are biased toward disclosed classes.
- Business-logic bugs are underrepresented.

Classical supervised models need dense labeled coverage by bug class. Transformer models start with broad pretraining over code and natural language, then adapt during prompting or fine-tuning. That prior helps on sparse classes like TOCTOU, multi-step auth bypass, and state confusion bugs.

### 4. Analyst-facing output quality

Classical classifiers usually return a score.

For engineering teams, a score is not enough. The triage loop needs:

- path from source to sink
- assumptions
- exploit preconditions
- concrete remediation

Modern LLM outputs are still imperfect, but they are usually better aligned with the workflow of a security review because they can produce a full argument that engineers can verify.

## Where this can still fail

None of this means LLM output is always correct.

Typical failure modes:

- plausible but wrong exploit chains
- framework-specific misunderstanding
- over-reporting under weak prompting
- missed bugs when context is truncated

The right operating model is layered, not model-only.

## A practical architecture that works in real teams

If the goal is production-grade vulnerability detection, I recommend this stack:

1. Deterministic analyzers for high-confidence known classes.
2. Transformer review pass for cross-file and semantic checks.
3. Policy layer that requires each finding to include:
   - source
   - sink
   - trust-boundary transition
   - exploit precondition
   - fix with affected lines
4. Validation harness with unit or integration tests that reproduce the issue.
5. Continuous measurement of false positives and false negatives by CWE class.

This keeps precision from rules while adding coverage for logic-heavy vulnerabilities.

## Closing

Classical ANN systems were and still are useful for narrow security classification problems.

For modern application security, the hard bugs are usually not single-token signatures. They are distributed logic failures that require context, semantic reasoning, and explicit argumentation.

That is where transformer LLMs are currently stronger, especially when used inside a disciplined verification pipeline.
